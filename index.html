<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300;400;700;900&display=swap"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Long+Cang&family=Permanent+Marker&display=swap"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Nanum+Pen+Script&family=Rubik+Mono+One&display=swap"
            rel="stylesheet"
        />
        <link href="https://fonts.googleapis.com/css2?family=Limelight&display=swap" rel="stylesheet" />

        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

        <!-- and it's easy to individually load additional languages -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

        <script>
            hljs.highlightAll();
        </script>

        <link rel="stylesheet" href="./Style/general.css" />
        <link rel="stylesheet" href="./Style/style.css" />
        <link rel="stylesheet" href="./Style/styleCornerKingdoms.css" />
        <link rel="stylesheet" href="./Style/styleImageToDots.css" />
        <link rel="stylesheet" href="./Style/styleAbout.css" />
        <link rel="stylesheet" href="./Style/styleMoreStuff.css" />

        <link rel="stylesheet" href="./Style/mediaQueries.css" />
        <script type="module" src="./CardInteraction.js"></script>
        <script type="module" src="./CardInteractionMobile.js"></script>
        <script type="module" src="./PageControl.js"></script>

        <title>Max Porter</title>
    </head>
    <body>
        <!-- duplicate header -->
        <header>
            <h1 class="my-name"><a href="/#">Max Porter</a></h1>
            <nav class="projects-navigation">
                <div class="projects-dropdown split-section">
                    <p>Projects</p>
                    <ion-icon class="projects-dropdown-chevron" name="chevron-forward-outline"></ion-icon>
                </div>
                <ul class="projects-nav-links"></ul>
            </nav>
            <ul class="social-links">
                <li>
                    <a href="https://github.com/MaximilianPorter" target="_blank" rel="noopener">
                        <ion-icon name="logo-github"></ion-icon>
                        <span>Github</span>
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/max-porter-290175196/" target="_blank" rel="noopener">
                        <ion-icon name="logo-linkedin"></ion-icon>
                        <span>LinkedIn</span>
                    </a>
                </li>
                <li>
                    <a href="mailto:mx.porters@gmail.com" target="_blank" rel="noopener">
                        <ion-icon name="mail-outline"></ion-icon>
                        <span>Email</span>
                    </a>
                </li>
                <li>
                    <!-- resume -->
                    <a href="./UpdatedResume.pdf" target="_blank" rel="noopener">
                        <ion-icon name="document-text-outline"></ion-icon>
                        <span>Resume</span>
                    </a>
                </li>
            </ul>
            <p class="desktop-tip">This website is much cooler if you're on a desktop by the way.</p>
        </header>
        <div class="start-page-cover">
            <p class="work-in-progress">WORK IN PROGRESS</p>
        </div>
        <div class="overlay-cover"></div>
        <div class="card-container-overlay">
            <div class="dropoff-location-card">
                <ion-icon class="dropoff-icon dropoff-icon--hidden" name="add-outline"></ion-icon>
                <div class="drag-card-info">
                    <p>Drag card here!</p>
                    <ion-icon name="arrow-down-outline"></ion-icon>
                </div>
            </div>
        </div>

        <div class="mobile-site">
            <div class="mobile-cards"></div>
        </div>
        <div class="cards-hand">
            <!-- <div class="card" data-id="corner-kingdoms">
        <div class="card-details">
          <ion-icon class="card-icon" name="game-controller-outline"></ion-icon>
          <p class="card-name">Card Name</p>
        </div>
        <img src="/Card Images/card_cornerkingdoms.png" alt="example card" />
      </div> -->
        </div>

        <div class="card-dragging-help-text card-dragging-help-text--hidden">
            <p>Drag Me.</p>
        </div>

        <section class="card-page-section card-page-section--hidden" data-id="about">
            <h2 class="about-title">Hi I'm Max.</h2>
            <p>
                I'm a <span class="age">23</span> year old <span class="highlight-word">game programmer</span> and
                <span class="highlight-word">designer</span>, and I've been making games for
                <span class="age-timer"></span> years. I published my first app on the Google Play store in 2016, and
                I'm currently working on an assortment of different projects with a focus on finding a job in the tech
                space and bettering myself as a programmer and devloper.
            </p>
            <div class="line-break"></div>
            <p>
                I built this portfolio website to showcase my abilities as a
                <span class="highlight-word">web developer</span>. Here, you can explore some of the projects I've
                created using skills I've developed over years of determined self-learning. I wanted to make something
                unique and since I make games, I thought it would be cool to make a website that feels like a game. I
                hope you enjoy it!
            </p>
            <br />
            <p>
                I have a strong perseverance for
                <span class="highlight-word-green">learning new things</span> and
                <span class="highlight-word-green">taking on challenges</span>, and I always like to put some extra time
                in polishing my creations, to make sure the creative vision is achieved in the best possible way. I've
                always been <span class="highlight-word-green">extremely curious</span> in the technical side of games,
                and sometimes this curiosity has led me to projects I won't be able to formally mention here... cough.
            </p>
            <br />
            <p>If you have any questions please feel free to contact me :)</p>

            <div class="line-break"></div>
            <div class="check-out-other-stuff">
                <p>Check out some more of this website</p>
                <div class="twitter-plug">
                    <p>Or check out my</p>
                    <a target="_blank" rel="noopener" href="https://twitter.com/TheMaxPorter"
                        ><ion-icon name="logo-twitter"></ion-icon>
                        <span>Twitter</span>
                    </a>
                </div>
            </div>
        </section>

        <section class="card-page-section card-page-section--hidden" data-id="corner-kingdoms">
            <div class="ck-title-section">
                <h2>Corner Kingdoms</h2>
            </div>
            <p class="ck-about">
                Corner Kingdoms is a splitscreen RTS game where players build up their kingdom and fight against their
                opponent. The game is built in
                <span class="highlight-word">Unity</span> and started because I wanted to expand a previous similar
                project named
                <a href="https://somebody-max.itch.io/birdsandblades" rel="noopener" target="_blank">Birds and Blades</a
                >. The game is currently in development.
            </p>

            <div class="ck-features-list">
                <ul>
                    <li>Exciting 2-4 player gameplay</li>
                    <li>Fight in teams or every man for themselves</li>
                    <li>Procedurally generated world every game</li>
                    <li>Simplified RTS style gameplay</li>
                    <li>No limit to army size. Bigger army, better person.</li>
                    <li>Resource graph after the game ends</li>
                </ul>
                <div class="ck-features-list-right">
                    <img
                        class="ck-features-screenshot"
                        src="/ProjectContent/CornerKingdoms/cornerkingdomssplitscreen.png"
                        alt="splitscreen screenshot"
                    />
                    <a
                        class="itch-link"
                        href="https://somebody-max.itch.io/corner-kingdoms"
                        rel="noopener"
                        target="_blank"
                        title="Store Page"
                    >
                        <img class="itch-button" src="https://static.itch.io/images/badge-color.svg" alt="" />
                    </a>
                </div>
            </div>

            <p class="ck-thumbnail-precursor">
                I have a couple development videos on the process of making this project.
            </p>
            <div class="ck-thumbnails">
                <a href="https://www.youtube.com/watch?v=D0sh_FXHDFI" rel="noopener" target="_blank" class="thumbnail">
                    <ion-icon name="play"></ion-icon>
                    <img
                        class="video-thumbnail-img"
                        src="/ProjectContent/CornerKingdoms/thumbnail0.jpg"
                        alt="thumbnail of devlog 0 for corner kingdoms"
                    />
                </a>
                <a href="https://www.youtube.com/watch?v=D0sh_FXHDFI" rel="noopener" target="_blank" class="thumbnail">
                    <ion-icon name="play"></ion-icon>
                    <img
                        class="video-thumbnail-img"
                        src="/ProjectContent/CornerKingdoms/thumbnail1.jpg"
                        alt="thumbnail of devlog 1 for corner kingdoms"
                    />
                </a>
                <a href="https://www.youtube.com/watch?v=D0sh_FXHDFI" rel="noopener" target="_blank" class="thumbnail">
                    <ion-icon name="play"></ion-icon>
                    <img
                        class="video-thumbnail-img"
                        src="/ProjectContent/CornerKingdoms/thumbnail2.jpg"
                        alt="thumbnail of devlog 2 for corner kingdoms"
                    />
                </a>
            </div>

            <div class="ck-mechanics">
                <h3 class="ck-simplicity-statement">Mechanics with a theme of simplicity.</h3>
                <div class="ck-mechanics-section">
                    <h4 class="page-scroll-link" id="ck-mechanics-movement">Movement</h4>
                    <p>
                        Players and units alike move around the map on a
                        <span class="highlight-word">Unity NavMesh</span>. This allows for easy pathfinding and
                        movement. As a comparison, the previous game I made,
                        <a href="https://somebody-max.itch.io/birdsandblades" rel="noopener" target="_blank"
                            >Birds and Blades</a
                        >, didn't use a <span class="highlight-word">pathfinding system</span>.
                    </p>
                    <br />
                    <div class="grid-2-row">
                        <p>
                            The units only moved in a straight line from point A to point B. This was a lot easier to
                            implement, but it didn't allow for any sort of interesting movement: walls couldn't be
                            added, and units couldn't move around each other. It just made for a cluster of a battle.
                        </p>

                        <p>
                            With the NavMesh, units can move around each other, and the player can add walls or towers
                            to block their opponent's units.
                        </p>
                        <img
                            src="./ProjectContent/CornerKingdoms/birdsandbladesPointABDemo.gif"
                            alt="gif of birds and blades units moving in a straight line"
                        />
                        <img
                            src="./ProjectContent/CornerKingdoms/pathfindingDemo.gif"
                            alt="gif of the current pathfinding system in work"
                        />
                    </div>
                    <br />
                    <p>
                        To save on <span class="highlight-word">performance</span>, the NavMesh is only generated once
                        at the start of the game. This way, the NavMesh doesn't have to be generated every frame. And
                        obstacles like walls and rocks use what's called a "Nav Mesh Obstacle" that cuts out a section
                        of the NavMesh so that units can't move through it.
                    </p>
                    <br />
                    <p>
                        The Movement system is also designed with <span class="highlight-word">reusability</span> in
                        mind. I use the same movement system for both the player and the units. This way, I don't have
                        to write 2 different movement systems, and I can easily add new units or creatures to the game.
                    </p>
                    <br />
                    <div class="grid-2-row break-early">
                        <img
                            src="./ProjectContent/CornerKingdoms/formationsDemo.gif"
                            alt="gif of how formations are structured"
                        />

                        <pre><code class="language-csharp">// BOX FORMATION MATH                    
float row = Mathf.FloorToInt(i / boxWidth);
float column = i % boxWidth;

// only apply if unit is in the last row (centering)
if (i >= lastRowStartIndex)
    column += remainderInLastRow / 2f;

Vector3 dir =
    transform.forward * (row + 1f) * patternSpacingMulti +
    transform.right * (column - boxWidth / 2f) * patternSpacingMulti;

dir = MaxPosWithHit(dir); // limit the position to only be on the NavMesh

SetUnitPos(unitsToRally[i], dir, unitsToRally[i].GetStats.maxMoveSpeed);</code></pre>
                        <p class="grid-span-columns">
                            Another cool aspect of the movemnt is the
                            <span class="highlight-word">formation system</span> that I added. You can hold a button and
                            cycle through various unit formations.
                        </p>
                    </div>
                </div>
                <div class="line-break"></div>
                <div class="ck-mechanics-section">
                    <h4 class="page-scroll-link" id="ck-mechanics-combat">Combat</h4>
                    <p>
                        The combat in Corner Kingdoms is a <span class="highlight-word">simplified</span> version of an
                        RTS game. The player can select their units with a circle that adds to their current selected
                        units.
                    </p>
                    <div class="grid-2-row break-early">
                        <img src="./ProjectContent/CornerKingdoms/selectingUnitsDemo.gif" alt="" />

                        <div class="match-width">
                            <pre><code class="language-csharp">private void SelectNearbyUnits()
{
    float distanceToPlayer = (unit.transform.position - transform.position).sqrMagnitude;
    selectedUnits = PlayerHolder.GetUnits(identifier.GetPlayerID)
        .Where(unit => distanceToPlayer < currentSelectionRadius * currentSelectionRadius && unit.GetIsSelectable).ToList();
}</code></pre>
                            <br />
                            <p class="subtitle">
                                The reason I use "sqrMagnitude" and not "magnitude" is because "magnitude" squares the
                                calculation automatically, making the process slower. So if I just compare
                                "sqrMagnitude" to the radius squared, I can get the same result, but faster.
                            </p>
                        </div>
                    </div>

                    <br />
                    <div class="split-section-reverse break-early">
                        <img src="./ProjectContent/CornerKingdoms/oneButtonAttackDemo.gif" alt="" />
                        <p>
                            And keeping the theme of simplicity, I went with a 1 button approach to combat. Once your
                            troops are selected, you can click the "Rally Troops" button to call your selected troops
                            towards your location. Depending on where you're standing and where your troops are relative
                            to enemies, the troops will attack the enemies.
                        </p>
                    </div>
                    <br />
                    <br />
                    <p>
                        Staying in the realm of troops attacking enemies, there were some interesting technical
                        difficulties that went into units finding the nearest enemy...
                    </p>

                    <div class="line-break"></div>
                    <h4 class="page-scroll-link" id="ck-mechanics-attack">Attack - Spatial Grid</h4>
                    <p>
                        When you have hundreds of units on the screen, it can be very taxing on the CPU to have each
                        unit check every other unit to see if it's the closest. You have to loop through every unit, and
                        then loop through every other unit to see if it's the closest. This is an
                        <span class="highlight-word">O(n^2) operation</span>, and it can get very slow very quickly.
                    </p>
                    <br />
                    <p>
                        So to combat this, I implemented a <span class="highlight-word">spatial grid</span>. The Spatial
                        Grid is a 2D array of lists. Each list contains all the units that are in that grid cell. When a
                        unit moves, it checks to see if it's grid cell has changed. If it has, it removes itself from
                        the old grid cell and adds itself to the new grid cell. So when a unit wants to find the nearest
                        enemy, it only has to check the units in it's grid cell and the surrounding grid cells. This is
                        a lot faster than checking every unit on the map.
                    </p>
                    <pre><code class="language-csharp">private void CellFindNearestEnemy()
{
    int cellsOutToCheck = Mathf.CeilToInt(lookRangeWithHeight / UnitCellManager.cellWidth);
    Cell activeCell = UnitCellManager.GetCell(transform.position);

    Vector2Int bottomLeft = new Vector2Int(activeCell.pos.x - cellsOutToCheck, activeCell.pos.y - cellsOutToCheck);
    Vector2Int topRight = new Vector2Int(activeCell.pos.x + cellsOutToCheck, activeCell.pos.y + cellsOutToCheck);
    Cell[] cellsAroundMe = UnitCellManager.GetCells(bottomLeft, topRight);


    SetNearestEnemy(ReturnClosestEnemy(cellsAroundMe));
}</code></pre>

                    <p>
                        This change severely reduced the complexity of finding the nearest enemy . This is a huge
                        improvement, and it allows for a lot more units to be on the screen at once.
                    </p>
                </div>
                <div class="line-break"></div>
                <div class="ck-mechanics-section">
                    <h4 class="page-scroll-link" id="ck-mechanics-ui">UI / UX</h4>
                    <p>
                        The UI is designed to be <span class="highlight-word">simple and easy to understand</span>. I
                        wanted the barrier of entry to be as low as possible, and when designing an RTS game, this can
                        have it's challenges. I think I've done a good job of making the game easy to understand, while
                        still having a lot of depth.
                    </p>
                    <br />
                    <div class="split-section break-early">
                        <p>
                            As the base UI, the player can see their resources (current and income/min) and the amount
                            of units they have. I like to have UI only show up when necessary as it removes confusion
                            for newer players and makes the game feel more immersive. So when the player selects a unit,
                            the UI changes to show which units are selected. Same goes for queuing units, the UI only
                            shows up when the player is queuing units.
                        </p>
                        <img src="./ProjectContent/CornerKingdoms/baseUI.png" alt="" />
                    </div>
                    <br />
                    <br />
                    <div class="split-section align-center">
                        <div>
                            <img class="margin-auto" src="./ProjectContent/CornerKingdoms/queuedUnits.png" alt="" />
                            <p class="subtitle margin-auto">UI shows up for when units are queued</p>
                        </div>
                        <div>
                            <img class="margin-auto" src="./ProjectContent/CornerKingdoms/selectedUnits.png" alt="" />
                            <p class="subtitle margin-auto">UI shows up for when units are selected</p>
                        </div>
                    </div>
                    <br />
                    <br />
                    <p>
                        And for the build menu, every RTS game that I see always has such a complicated build/upgrade
                        menu. I think when you're playing a "party game" with friends, you don't want to have to spend a
                        lot of time learning the game. So I wanted to make the build menu as simple as possible as well.
                    </p>
                    <br />
                    <br />
                    <div class="split-section break-early">
                        <p>
                            When first opening the build menu, the player is presented with only a couple buildings. A
                            way that I achieved a simpler build menu is through an upgrade system. The player can
                            upgrade their buildings to change the building in some way.
                        </p>
                        <img src="./ProjectContent/CornerKingdoms/purchasingBuildingsDemo.gif" alt="" />
                    </div>
                    <br />
                    <div class="split-section break-early">
                        <img src="./ProjectContent/CornerKingdoms/upgradingBuildingsDemo.gif" alt="" />
                        <p>
                            For example: a player places down a house to increase population. From there, they can
                            upgrade this house into a village house, an archery range, or a blacksmitch. This way, the
                            player doesn't have to learn what each building does, they can just upgrade their buildings
                            to get the desired effect and thus a simpler build menu.
                        </p>
                    </div>
                </div>
                <div class="line-break"></div>
                <div class="ck-mechanics-section">
                    <h4 class="page-scroll-link" id="ck-mechanics-procedural-generation">Procedural Generation</h4>
                    <p>
                        The map is <span class="highlight-word">procedurally generated</span> every game. Certain
                        elements of the map don't matter as much due to a surplus of resources, like trees. Those are
                        generated using the <span class="highlight-word">Perlin Noise</span>
                        algorithm.
                    </p>
                    <br />
                    <div class="split-section align-center">
                        <img src="./ProjectContent/CornerKingdoms/perlinNoise.png" alt="" />
                        <img src="./ProjectContent/CornerKingdoms/perlinNoiseTrees.png" alt="" />
                    </div>
                    <br />
                    <div class="split-section break-early">
                        <p>
                            But other elements that aren't as common are generated with a grid division algorithm. This
                            algorithm divides the map into a grid, places at least x objects in each cell, then randomly
                            places objects in each grid cell. This way, the map is always different, but resources are
                            distributed evenly.
                        </p>
                        <img src="./ProjectContent/CornerKingdoms/evenMapDistribution.gif" alt="" />
                        <img
                            src="./ProjectContent/CornerKingdoms/MapGroupsDemo.gif"
                            alt="an example of what the map groups look like in Corner Kingdoms"
                        />
                    </div>
                    <br />
                    <div class="split-section break-early">
                        <img src="./ProjectContent/CornerKingdoms/poorMapDistributionBOB.gif" alt="" />
                        <p>
                            In
                            <a href="https://somebody-max.itch.io/birdsandblades" rel="noopener" target="_blank"
                                >Birds and Blades</a
                            >
                            I just randomly placed objects on the map, but this led to the map being very unbalanced.
                            Simply put, the location of your spawn heavily dictated who would win the game. So I wanted
                            to make sure that the map was balanced, but still different every game.
                        </p>
                    </div>

                    <img src="./ProjectContent/CornerKingdoms/" alt="" />
                </div>
            </div>
        </section>

        <section class="card-page-section card-page-section--hidden" data-id="more-games">
            <div class="more-showcase-area">
                <div class="more-showcase-video-area">
                    <p class="more-stuff-header-text">
                        SOME <br />
                        OTHER <br />STUFF
                    </p>
                    <video
                        class="more-showcase-video"
                        src="./ProjectContent/More/allMyProjectsMontageBetterQuality.mp4"
                        autoplay="autoplay"
                        loop="loop"
                        muted="muted"
                    ></video>
                    <video
                        class="more-showcase-video-underlay"
                        src="./ProjectContent/More/allMyProjectsMontageBetterQuality.mp4"
                        autoplay="autoplay"
                        loop="loop"
                        muted="muted"
                    ></video>
                </div>
                <div class="scroller">
                    <div class="scroller-row more-scroller-images" data-duration="long"></div>
                    <div class="scroller-row more-scroller-images" data-duration="medium" data-direction="right"></div>
                    <div class="scroller-row more-scroller-images" data-duration="medium"></div>
                </div>
            </div>
            <div class="notable-projects">
                <h4 class="notable-projects-header">Notable Projects</h4>
                <div class="notable-projects-holder split-section break-early">
                    <!-- birds and blades -->
                    <div class="notable-project">
                        <div class="notable-project-header-area">
                            <ion-icon class="notable-project-icon" name="game-controller-outline"></ion-icon>
                            <h5 class="notable-project-header">Birds and Blades</h5>
                        </div>
                        <p class="notable-project-description">
                            Birds and Blades is another splitscreen RTS game built in Unity. It's kind of like the
                            predecessor to Corner Kingdoms. I would say it's more complete as an all around game, but
                            Corner Kingdoms is more thought out with it's mechanics and design.
                            <br />
                            <br />
                            <span class="notable-link">
                                <ion-icon name="log-out-outline"></ion-icon>
                                <a href="https://somebody-max.itch.io/birdsandblades" rel="noopener" target="_blank"
                                    >Store Page</a
                                >
                            </span>
                        </p>

                        <div class="notable-project-extra"></div>

                        <img
                            class="notable-project-background-img"
                            src="./ProjectContent\More\birdsAndBladesScreenshot.jpg"
                            alt=""
                        />
                    </div>
                    <div class="notable-project">
                        <div class="notable-project-header-area">
                            <ion-icon class="notable-project-icon" name="laptop-outline"></ion-icon>
                            <h5 class="notable-project-header">worldclassgamer.com</h5>
                        </div>
                        <p class="notable-project-description">
                            This website was one of the first working websites I made. It's a website that uses a
                            <span class="highlight-word">server side</span> script to send SteamAPI data to the frontend
                            using <span class="highlight-word">Firebase Functions</span>.
                            <br />
                            <br />
                            <span class="notable-link">
                                <ion-icon name="logo-github"></ion-icon>
                                <a
                                    href="https://github.com/MaximilianPorter/world-class-gamer"
                                    rel="noopener"
                                    target="_blank"
                                    >GitHub</a
                                >
                            </span>
                        </p>
                        <div class="notable-project-extra"></div>

                        <img
                            class="notable-project-background-img"
                            src="./ProjectContent\More\worldclassgamerScreenshot.png"
                            alt=""
                        />
                    </div>
                    <div class="notable-project">
                        <div class="notable-project-header-area">
                            <ion-icon class="notable-project-icon" name="laptop-outline"></ion-icon>
                            <h5 class="notable-project-header">Rocket League Showmatches</h5>
                        </div>
                        <p class="notable-project-description">
                            A website that uses the
                            <span class="highlight-word">Liquipedia API</span> to get data about the game Rocket League.
                            <br />
                            <br />
                            I use that data to make my own <span class="highlight-word">API</span> to send data in a
                            more usable format to the frontend.
                            <br />
                            <br />
                            <span class="notable-link">
                                <ion-icon name="logo-github"></ion-icon>
                                <a
                                    href="https://github.com/MaximilianPorter/johnnyboi-showmatches"
                                    rel="noopener"
                                    target="_blank"
                                    >GitHub</a
                                >
                            </span>
                        </p>

                        <div class="notable-project-extra">
                            <p>
                                Some context: JohnnyBoi is a Rocket League caster who hosts showmatches (1v1
                                tournaments) with the best players in the world. I wanted to make a website that
                                displayed the upcoming showmatches in a more
                                <span class="highlight-word">user friendly</span> way than the liquipedia page.
                            </p>
                            <br />
                            <p>
                                This website uses liquipedia's api to fetch data from the JohnnyBoi_i/Broadcasts page
                                and subsequent match pages. I have to cache the data because of the restrictions on api
                                calls. The data retrieved is basically just the page's html, so I use the
                                <span class="highlight-word">jsdom</span> npm library to parse the html on a back-end
                                server.
                            </p>
                            <br />
                            <p>
                                This website is not active due to financial reasons, but you can read more about it and
                                check the source code
                                <a
                                    href="https://github.com/MaximilianPorter/johnnyboi-showmatches"
                                    rel="noopener"
                                    target="_blank"
                                    >HERE!</a
                                >
                            </p>
                            <img
                                class="notable-project-extra-img"
                                src="./ProjectContent/More/johnnyboiWebsiteDemo.gif"
                                alt=""
                            />
                        </div>

                        <img
                            class="notable-project-background-img"
                            src="./ProjectContent\More\johnnyboiScreenshot.png"
                            alt=""
                        />
                    </div>
                    <!-- world class gamer -->
                    <!-- johnnyboi -->
                </div>
            </div>
        </section>

        <section class="card-page-section card-page-section--hidden" data-id="image-to-dots">
            <div class="itd-title-section">
                <h2>Image to Dots</h2>
                <video
                    src="./ProjectContent/ImagetoDots/dots-short-demo.mp4"
                    autoplay="autoplay"
                    loop="loop"
                    muted="muted"
                ></video>
            </div>
            <p class="itd-about">
                Image to Dots is a <span class="highlight-word">Web Application</span> that converts an image into a
                series of colored dots. The program is written in <span class="highlight-word">JavaScript</span>,
                <span class="highlight-word-html">HTML</span>, and <span class="highlight-word-css">CSS</span>.
                <br />
                <br />
                <a href="https://imagetodots.netlify.app/" rel="noopener" target="_blank"> TRY IT OUT. </a>
            </p>

            <!-- <div class="line-break"></div>

            <div class="itd-try-it-out">
                <iframe
                    src="https://imagetodots.netlify.com"
                    frameborder="0"
                    title="Image to Dots"
                    class="itd-iframe"
                ></iframe>
            </div> -->

            <div class="line-break"></div>

            <div class="itd-watch-development">
                <a href="https://www.youtube.com/watch?v=adoa-eBZ-w8" rel="noopener" target="_blank" class="thumbnail">
                    <ion-icon name="play"></ion-icon>
                    <img
                        class="video-thumbnail-img"
                        src="/ProjectContent/ImagetoDots/imagetodotsThumbnail.jpg"
                        alt="thumbnail of devlog 0 for corner kingdoms"
                    />
                </a>
                <a href="https://www.youtube.com/watch?v=adoa-eBZ-w8" rel="noopener" target="_blank">
                    CHECK OUT THE DEVELOPMENT VIDEO.
                </a>
            </div>

            <div id="itd-how-to-use" class="itd-how-to-use">
                <h3 class="page-scroll-link">How to use</h3>
                <div class="itd-how-to-use-section">
                    <!-- 1. upload an image -->
                    <div class="itd-how-to-use-step split-section">
                        <div class="itd-how-to-use-step-text">
                            <h4>1. Upload an image</h4>
                            <p>
                                The image can be any size, but the larger the image, the longer it will take to process.
                                From testing, higher contrast images work better.
                            </p>
                        </div>
                        <video
                            class="itd-how-to-use-media split-child-50"
                            src="./ProjectContent/ImagetoDots/uploadpicture.mp4"
                            autoplay="autoplay"
                            loop="loop"
                            muted="muted"
                        ></video>
                    </div>
                    <!-- 2. mess with the settings -->
                    <div class="itd-how-to-use-step split-section-reverse">
                        <div class="itd-how-to-use-step-text">
                            <h4>2. Mess Around</h4>
                            <p>
                                There are lots of settings to tweak to get the image to look how you'd like it. Or you
                                could just mess around with them and have fun.
                            </p>
                        </div>
                        <video
                            class="itd-how-to-use-media split-child-50"
                            src="./ProjectContent/ImagetoDots/messwithsettings.mp4"
                            autoplay="autoplay"
                            loop="loop"
                            muted="muted"
                        ></video>
                    </div>
                    <!-- 3. download the image -->
                    <div class="itd-how-to-use-step split-section">
                        <div class="itd-how-to-use-step-text">
                            <h4>3. Save Your Image</h4>
                            <p>Once you're happy with the image, you can download it and use it however you'd like.</p>
                        </div>
                        <video
                            class="itd-how-to-use-media split-child-50"
                            src="./ProjectContent/ImagetoDots/savevideo.mp4"
                            autoplay="autoplay"
                            loop="loop"
                            muted="muted"
                        ></video>
                    </div>
                </div>
            </div>

            <div class="itd-image-processing">
                <h3 class="page-scroll-link">Image Processing</h3>
                <p>
                    When I first load the image from the user input, I have to process it into a format that I can use.
                    I use the <span class="highlight-word">canvas</span> element to draw the image onto a canvas, then I
                    get the pixel data from the canvas.
                </p>
                <br />
                <p>
                    I create a set number of dots based on how smoothly I want the program to run (more dots = more
                    lag). And when the dots move, I loop through each dot and set it's position and color based on the
                    pixel data.
                </p>
                <pre><code class="language-javascript">function getPixelValue(xPercent, yPercent, imageData) {
    const x = Math.floor(xPercent * imageData.width);
    const y = Math.floor(yPercent * imageData.height);
    const index = (y * imageData.width + x) * 4;

    // return value 0 1
    return imageData.data[index] / 255;
}</code></pre>
                <br />
                <div class="split-section align-center break-early">
                    <div class="split-child-50">
                        <video
                            src="./ProjectContent/ImagetoDots/pixelValueExample.mp4"
                            autoplay="autoplay"
                            loop="loop"
                            muted="muted"
                        ></video>
                        <p class="subtitle center-text">
                            What is the value of a pixel? <br />
                            It's just a number between 0 and 1.
                        </p>
                    </div>
                    <br />
                    <div class="split-child-50">
                        <video
                            src="./ProjectContent/ImagetoDots/pixelValueMappingExample.mp4"
                            autoplay="autoplay"
                            loop="loop"
                            muted="muted"
                        ></video>
                        <p class="subtitle center-text">
                            I use the position of the dot to see what color it should be.
                        </p>
                    </div>
                </div>
                <br />
                <p>
                    I use the position of the dot to get the pixel data from the image. Then I use that pixel data to
                    handle both the dot radius and the dot collision.
                </p>
                <br />
                <pre><code class="language-javascript">function UpdateDotRadius(dot) {
    const {
        position,
        radius
    } = dot;
    const positionPercent = {
        x: help.Clamp(position[0] / dotsAreaCanvas.width, 0.0001, 0.9999),
        y: help.Clamp(position[1] / dotsAreaCanvas.height, 0.0001, 0.9999),
    };
    const pixelValue = getPixelValue(
        positionPercent.x,
        positionPercent.y,
        uploadedImageData
    );

    if (!pixelValue) return;

    // 0 - darkestPixelValue
    // 1 - brightestPixelValue
    const valueRange = brightestPixelValue - darkestPixelValue;
    const relativeValue = (pixelValue - darkestPixelValue) / valueRange;

    const desiredRadius = help.Lerp(
        minDotRadius,
        maxDotRadius,
        dotBezier.GetDotSizeBezierCurve(relativeValue)[1]
    );
    dot.radius += (desiredRadius - radius) * radiusChangeRate;

    dot.detectionRadius = dot.radius + CELL_SIZE * (dot.moveSpeed / dotSpeed);
    dot.collisionRadius = dot.detectionRadius * collisionRadiusMultiplier;
}</code></pre>
                <br />
                <p>
                    Dot collision however, though it may seem as if it is handled by the dot radius, is actually handled
                    by a <span class="highlight-word">Boid Algorithm</span>. And really isn't effected by the dot
                    radius.
                </p>
            </div>
            <div class="itd-boid-algorithm">
                <h3 class="page-scroll-link">Boid Algorithm</h3>
                <p>
                    The <span class="highlight-word">Boid Algorithm</span> is a way to simulate flocking behavior. It's
                    used in a lot of games to simulate the movement of birds or fish. It's a very simple algorithm, but
                    it can produce some very interesting results.
                </p>
                <br />
                <p>
                    The algorithm is split into 3 parts: <span class="highlight-word">Alignment</span>,
                    <span class="highlight-word">Cohesion</span>, and <span class="highlight-word">Separation</span>.
                    Alignment is the average direction of all the nearby dots. Cohesion is the average position of all
                    the nearby dots. And Separation is the average distance of all the nearby dots.
                </p>
                <br />
                <div class="boids-examples split-section break-early">
                    <video
                        src="./ProjectContent/ImagetoDots/boids_alignmentExample.mp4"
                        autoplay="autoplay"
                        loop="loop"
                        muted="muted"
                    ></video>
                    <video
                        src="./ProjectContent/ImagetoDots/boids_cohesionExample.mp4"
                        autoplay="autoplay"
                        loop="loop"
                        muted="muted"
                    ></video>
                    <video
                        src="./ProjectContent/ImagetoDots/boids_separationExample.mp4"
                        autoplay="autoplay"
                        loop="loop"
                        muted="muted"
                    ></video>
                </div>
                <br />
                <p>I use these 3 values to calculate the <em>direction</em> of the dot based on certain weights.</p>

                <div>
                    <br />
                    <pre><code class="language-javascript">function SteerDirection(dot, otherDots) {
    const ratio = 1 - help.Clamp(distance2 / (detectionRadius * detectionRadius), 0, 1);
    direction = direction.map((dir, i) => {
        // turn away from other dot
        dir -= dotsVector[i] * ratio * separationFactor;
        // align with other dot
        dir += otherDot.moveDirection[i] * alignmentFactor;
        return dir;
    });

    // steer away from mouse
    const mouseVector = help.VectorDirection(dot.position, canvasMousePosition);
    direction = direction.map(
        (dir, i) => dir - mouseVector[i] * steerFromMouseFactor * edgeBezier
    );

    // turn towards larger dots
    const dotsVector = help.VectorDirection(dot.position, largestDot.position);
    direction = direction.map(
        (dir, i) => dir + dotsVector[i] * turnTowardsLightFactor
    );

    // apply wind force (-1 left to 1 right)
    direction = direction.map((dir, i) => dir + windFactor * (i === 0 ? 1 : 0));

    // final direction
    const desiredDirection = help.VectorDirection(dot.position, [
      xposAvg,
      yposAvg,
    ]);
    direction = direction.map(
      (dir, i) => dir + desiredDirection[i] * centeringFactor
    );

    return direction;
}</code></pre>
                    <p class="subtitle center-text">Simplified for viewing purposes.</p>

                    <br />
                </div>
            </div>
            <div class="itd-settings">
                <h3 class="page-scroll-link">Settings</h3>
                <p>
                    I use an <span class="highlight-word">object</span> to hold all the settings that can be adjusted by
                    the user. This way, I can <span class="highlight-word">easily add new settings</span> without having
                    to change the code too much.
                </p>
                <br />
                <div class="split-section align-center">
                    <div class="split-child-50">
                        <pre><code class="language-javascript">class Debug_Settings extends Settings {
    constructor() {
        super();
        this.isDrawingDebug = true;

        this.CELL_SIZE = 50;
        this.dotSpeed = 0.9;
        this.maxDotRadius = 10;
        this.minDotRadius = 0.001;
        this.centeringFactor = 0.1;
        this.alignmentFactor = 0.1;
        this.turnTowardsLightFactor = 0.001;
        this.separationFactor = 1;
    }
}
const debugSettings = new Debug_Settings();</code></pre>
                        <p class="subtitle center-text">I can extend the class for debug settings...</p>
                    </div>
                    <div class="split-child-50">
                        <pre><code class="language-javascript">class MoreDots_Settings extends Settings {
    constructor() {
        super();
        this.CELL_SIZE = 20;
        this.dotsToAdd = 3000;
        this.dotSpeed = 0.5;
        this.maxDotRadius = 10;
        this.minDotRadius = 0.001;
        this.centeringFactor = 0.1;
        this.alignmentFactor = 1;
        this.turnTowardsLightFactor = 0.001;
        this.separationFactor = 1;
        this.slownessFactor = 0.1;
    }
}</code></pre>
                        <p class="subtitle center-text">Or any other bundle of settings I prefer.</p>
                    </div>
                </div>
                <br />
                <p class="center-text">I just have to change the ones I want if I want to make certain packs</p>
            </div>
            <div class="itd-spatial-grid">
                <h3 class="page-scroll-link">Spatial Grid</h3>
                <p>
                    The <span class="highlight-word">Spatial Grid</span> is a way to reduce the complexity of finding
                    the nearest dot and <span class="highlight-word">improves performance</span>. It's a
                    <span class="highlight-word">2D array</span> of lists. Each list contains all the dots that are in
                    that grid cell.
                </p>
                <br />
                <div>
                    <video
                        src="./ProjectContent/ImagetoDots/SpatialGridDotsExample.mp4"
                        autoplay="autoplay"
                        loop="loop"
                        muted="muted"
                    ></video>
                    <p class="subtitle center-text">
                        When looping through a large list, each dot has to check every other dot to see if it's going to
                        collide.
                    </p>
                    <p class="subtitle center-text">
                        But with a spatial grid, the dot only needs to check nearby grid cells.
                    </p>
                    <br />
                    <p class="subtitle center-text">*EXPLAINED BETTER IN THE VIDEO*</p>
                </div>
                <br />
                <p>
                    When a dot moves, it checks to see if it's grid cell has changed. If it has, it removes itself from
                    the old grid cell and adds itself to the new grid cell. So when a dot wants to find the nearest dot,
                    it only has to check the dots in it's grid cell and the surrounding grid cells. This is
                    <span class="highlight-word">a lot faster</span>
                    than checking every dot on the map.
                </p>
                <br />
                <br />
                <div class="split-section break-early">
                    <div>
                        <p>
                            Using a <em>cell size</em> constant, I can create a grid of cells. This
                            <em>cell size</em> number also dictates how performant the application will be.
                        </p>
                        <br />
                        <p class="subtitle">
                            Smaller cell size = less dots to check = more performant (but less accurate)
                            <br />
                            Larger cell size = more dots to check = less performant (but more accurate)
                        </p>
                    </div>
                    <pre><code class="language-javascript">function createGrid(width, height, cellSize) {
    const grid = {};
    for (let i = 0; i < width / cellSize; i++) {
        for (let j = 0; j < height / cellSize; j++) {
        grid[`${i},${j}`] = [];
        }
    }
    return grid;
}</code></pre>
                </div>
                <br />
                <br />
                <div class="split-section-reverse break-early">
                    <p>
                        I can get the neighboring cells by adding or subtracting 1 from the x and y values. This way, I
                        can get the 8 cells surrounding the current cell.
                    </p>
                    <pre><code class="language-javascript">function getNeighboringCells(grid, gridPosition, cellSize, canvas) {
    const neighboringCells = [
        `${gridPosition.x},${gridPosition.y}`,
        `${gridPosition.x},${gridPosition.y - 1}`, // this can be undefined
        `${gridPosition.x},${gridPosition.y + 1}`, // this can be undefined
        `${gridPosition.x - 1},${gridPosition.y}`, // this can be undefined
        `${gridPosition.x - 1},${gridPosition.y - 1}`,
        `${gridPosition.x - 1},${gridPosition.y + 1}`,
        `${gridPosition.x + 1},${gridPosition.y}`, // this can be undefined
        `${gridPosition.x + 1},${gridPosition.y - 1}`,
        `${gridPosition.x + 1},${gridPosition.y + 1}`,

        // plus some other math to check for dots looping around the canvas
        // ...
    ];
    
    return neighboringCells;
}</code></pre>
                </div>
                <br />
                <br />
                <div class="split-section break-early">
                    <p>Using that information, I can get all the dots in the neighboring cells.</p>
                    <pre><code class="language-javascript">function GetDotsInNeighboringCells(dot) {
    const { gridPosition } = dot;
    const neighboringCells = getNeighboringCells(
        grid,
        gridPosition,
        CELL_SIZE,
        dotsAreaCanvas
    );
    
    const dotsInNeighboringCells = [];
    
    for (let i = 0; i < neighboringCells.length; i++) {
        if (grid[neighboringCells[i]] === undefined) 
            continue;
        const cell = neighboringCells[i];
        const cellDots = grid[cell];
        cellDots.forEach((dot) => {
        dotsInNeighboringCells.push(dot);
        });
    }
    
    return dotsInNeighboringCells;
}</code></pre>
                </div>
            </div>
            <div>
                <div class="itd-final-note">
                    <p>
                        <a href="https://www.youtube.com/watch?v=adoa-eBZ-w8" target="_blank" rel="noopener noreferrer">
                            ---> Watch the video <---
                        </a>
                    </p>
                    <p>for a cooler explanation</p>
                </div>
            </div>
        </section>

        <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
    </body>
</html>
